# Руководство пользователя stm32-cmake-yml

Файл `stm32_config.yml` является ядром вашего проекта. Изменяя его, вы управляете всем процессом сборки без необходимости писать код на CMake.

## 1. Режимы работы: IOC против Ручной настройки

Фреймворк поддерживает два основных режима получения данных о микроконтроллере:

* **Интеграция с STM32CubeMX (`ioc_file`)**: Если вы укажете путь к файлу `.ioc`, фреймворк автоматически считает из него модель MCU, размеры Heap/Stack и версию библиотек.
    ```yaml
    ioc_file: "my_project.ioc"
    ```
* **Ручной режим**: Если `ioc_file` закомментирован или пуст, вы должны явно указать модель контроллера:
    ```yaml
    mcu: "STM32F401CCU6"
    heap_size: "512"
    stack_size: "1K"
    ```

## 2. Исходные файлы и модули (`sources`)

В секции `sources` указываются файлы и папки, участвующие в сборке. 
**Важно:** Любая папка, указанная здесь (например, `Core`), должна содержать собственный файл `CMakeLists.txt` для сборки статической библиотеки.

```yaml
sources:
  - "Core"          # Папка-модуль
  - "Middlewares"   # Папка-модуль
  - "main.cpp"      # Отдельный файл в корне
```

## 3. Драйверы и RTOS

Управление подключением компонентов от STMicroelectronics:

```yaml
use_cmsis: true
use_hal: true
hal_components:
  - "RCC"
  - "GPIO"
  - "LL_USB" # Использование префикса LL_ автоматически добавляет нужные дефайны

use_freertos: true
freertos_components:
  - "ARM_CM4F" # Обязательно укажите порт ядра!
  - "Heap::4"  # Обязательно укажите тип кучи!
  - "Timers"
cmsis_rtos_api: "v2" # Обертка CMSIS-RTOS ("v1", "v2" или "none")
```

## 4. Контроль целостности прошивки (CRC32)

Фреймворк поддерживает автоматический расчет аппаратного CRC32 и его внедрение в конец прошивки. Это позволяет реализовать самопроверку устройства при загрузке. Для работы механизма требуется установленный **Python 3**.

```yaml
# Включение функции внедрения CRC
enable_crc: true

# Имя секции в скрипте компоновщика (.ld), куда будет записан результат
crc_section_name: ".checksum"

# Алгоритм (по умолчанию эмулирует аппаратный CRC STM32 F1/F4/F7)
crc_algorithm: "STM32_HW_DEFAULT"
```

**⚠️ ВАЖНО: Требование к скрипту компоновщика (Linker Script)**
Чтобы внедрение сработало, в вашем `.ld` файле (или `.ld.in` шаблоне) обязательно должна присутствовать секция, имя которой совпадает с `crc_section_name`. Поместите её в конец памяти `FLASH`:

```ld
  .checksum :
  {
    . = ALIGN(4);
    __checksum_start = .;
    LONG(0); /* Резервируем 4 байта под CRC */
    __checksum_end = .;
  } >FLASH
  __checksum_size = __checksum_start - ORIGIN(FLASH);
```
Если механизм сработает успешно, в логе сборки вы увидите:
` Calculated: 0x6DF1B9CF (Size: 78864 bytes)`

## 5. Отладка и диагностика сборки

Если проект не собирается или вы хотите понять, какие флаги применяются под капотом, используйте эти опции:

```yaml
# Проверка, что заданные Heap/Stack физически помещаются в RAM контроллера
validate_linker_script: true

# Вывод детальной информации о флагах (includes, defines) в лог CMake
log_target_properties: true

# Вывод полных команд компилятора GCC в терминал при сборке
verbose_build: true
```